# -*- coding: utf-8 -*-
"""Optimisation_V1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q22MCAdsVF3UsbcMCQ6BuaBxnPSkQm7I
"""

# !pip install --force-reinstall numpy==1.23.5
# !pip install tsplib95
# !pip install osmnx
# !pip install networkx
# !pip install folium
# !pip install -U scikit-learn

import osmnx as ox
import networkx as nx
import folium
import tsplib95
import tsplib95.distances as distances
from itertools import permutations
import itertools
import folium.plugins

ox.config(use_cache=True, log_console=True)

import random
random.seed(12235)
def generate_positions(num_patients, num_hospitals, num_ambulances):
    # Charger un graphe routier pour une zone spécifique
    point_central = (48.8566, 2.3522)

    rayon = 3000

    G = ox.graph_from_point(point_central, dist=rayon, network_type="all")

    hospitals = {}
    patients = {}
    ambulances = {}


    hospital_positions = [(d['y'], d['x']) for d in [random.choice(list(G.nodes.values())) for _ in range(num_hospitals)]]
    for j in range(num_hospitals):
      hospitals[hospital_positions[j]] = 30


    # Générer des positions aléatoires pour les patients, les hôpitaux et les ambulances
    patient_positions = [(d['y'], d['x']) for d in [random.choice(list(G.nodes.values())) for _ in range(num_patients)]]

    j = 0
    id = []
    while j < num_patients:
      i = random.randint(10_000_00000, 99_999_99999)
      if i not in id:
        id.append(i)
        patients[id[j]] = [patient_positions[j]]
        j += 1

    ambulance_positions = [hospital_positions[i % num_hospitals] for i in range(num_ambulances)]
    ambulance_positions = [(i+0.000001, j+0.000001) for i, j in ambulance_positions]

    im = []
    k = 0
    while k < num_ambulances:
      i = random.randint(1000_0000, 9999_9999)
      if i not in im:
        im.append(i)
        ambulances[im[k]] = {ambulance_positions[k] : ambulance_capacities[k]}
        k += 1



    return patients, hospitals, ambulances

# Retrieve the graph of the city of Paris with OSMnx
G = ox.graph_from_place('Paris, France', network_type='drive')



num_patients = 25
num_hospitals = 5
num_ambulances = 10

hospital_capacities = [20]*num_hospitals
ambulance_capacities = [4]*num_ambulances

patients, hospitals, ambulances = generate_positions(num_patients, num_hospitals, num_ambulances)

# Function to initialize the map
def initialize_map(center, zoom):
    m = folium.Map(location=center, zoom_start=zoom)
    return m

# Generate random patient states (0 or 1)
patient_urgency = random.choices([90, 4*60, 24*60], weights=[0.2, 0.3, 0.5], k=num_patients)
patient_states = [1 if i == 1 else random.randint(0,1) for _, i in enumerate(patient_urgency)]


# Initialize the map
map_center = (48.8566, 2.3522)  # Coordinates of Paris, for example
zoom_start = 14
m = initialize_map(map_center, zoom_start)

print('ambulances : ', ambulances)
print('patients : ', patients)
print('hopitaux : ', hospitals)

print(patient_urgency)
print(patient_states)

for i,j in enumerate(patients):
  patients[j].append((patient_urgency[i],patient_states[i]))
  print(patients[j])
  patients[j] = patients[j][::len(patients[j])-1]
  print(patients[j])

import geopy.distance

def time_based_heuristic(node1, node2, G):
    speed_limit = 50 / 3.6  # Assuming a maximum speed limit of 50 km/h in the city (converted to m/s)
    node1_coord = (G.nodes[node1]['y'], G.nodes[node1]['x'])
    node2_coord = (G.nodes[node2]['y'], G.nodes[node2]['x'])
    straight_line_distance = geopy.distance.distance(node1_coord, node2_coord).m
    return straight_line_distance / speed_limit

from functools import partial

def path_length(G, path):
    return sum(G.edges[path[i], path[i+1], 0]['length'] for i in range(len(path) - 1))

patients

def data_patients_ambulances_hospitals(patients, ambulances, hospitals):

  ambulance_nodes = list(ambulances.keys())
  ambulance_coords = [list(ambulance.keys())[0] for ambulance in ambulances.values()]
  ambulance_capacity = {node: list(ambulance.values())[0] for node, ambulance in zip(ambulance_nodes, ambulances.values())}

  patient_nodes = list(patients.keys())
  patient_coords = [i[0] for i in list(patients.values())]
  patient_urgence_etat = [i[1] for i in list(patients.values())]

  hospital_nodes = []
  hospital_coords = []
  hospital_capacities = []

  for hospital_coord, capacity in hospitals.items():
      hospital_coords.append(hospital_coord)
      hospital_capacities.append(capacity)

  ambulance_nodes = {i:j for i,j in zip(ambulance_nodes, [ox.distance.nearest_nodes(G, X=[coord[1]], Y=[coord[0]])[0] for coord in ambulance_coords])}
  patient_nodes = {i:j for i,j in zip(patient_nodes, [ox.distance.nearest_nodes(G, X=[coord[1]], Y=[coord[0]])[0] for coord in patient_coords])}
  hospital_nodes = [ox.distance.nearest_nodes(G, X=[coord[1]], Y=[coord[0]])[0] for coord in hospital_coords]


  return ambulance_nodes, ambulance_coords, ambulance_capacity, patient_nodes, patient_coords, patient_urgence_etat, hospital_nodes, hospital_coords, hospital_capacities

ambulance_nodes, ambulance_coords, ambulance_capacity, patient_nodes, patient_coords, patient_urgence_etat, hospital_nodes, hospital_coords, hospital_capacities = data_patients_ambulances_hospitals(patients, ambulances, hospitals)

from collections import defaultdict

def assign_patients_with_respect_to_evacuation_time(G, ambulance_nodes, patient_nodes, patient_urgence_etat, ambulance_capacities, hospital_capacities):

    assignments = defaultdict(list)
    ambulance_patients = defaultdict(list)
    hospital_patients = defaultdict(list)

    patient_urgency = [u for u, s in patient_urgence_etat]
    patient_states = [s for u, s in patient_urgence_etat]

    remaining_ambulance_capacity = dict(ambulance_capacity)
    remaining_hospital_capacities = list(hospital_capacities)

    sorted_patient_indices = sorted(patient_nodes.keys(), key=lambda i: patient_urgency[list(patient_nodes.keys()).index(i)], reverse=False)
    # print(sorted(patient_nodes.keys(), key=lambda i: patient_urgency[list(patient_nodes.keys()).index(i)], reverse=True))
    # print(sorted_patient_indices)
    for patient_id in sorted_patient_indices:
        min_time = float('inf')
        chosen_ambulance = None
        chosen_hospital = None

        for ambulance_id, capacity in remaining_ambulance_capacity.items():
            if capacity >= 2 * (patient_states[list(patient_nodes.keys()).index(patient_id)] + 1):

                for hospital_idx, hospital_capacity in enumerate(remaining_hospital_capacities):
                    if hospital_capacity > 0:
                        try:
                            time_to_evacuate = nx.shortest_path_length(G, ambulance_nodes[ambulance_id], patient_nodes[patient_id]) + \
                                               nx.shortest_path_length(G, patient_nodes[patient_id], hospital_nodes[hospital_idx])
                        except nx.NetworkXNoPath:
                            continue

                        if time_to_evacuate <= patient_urgency[list(patient_nodes.keys()).index(patient_id)] and time_to_evacuate < min_time:
                            min_time = (patient_urgency[list(patient_nodes.keys()).index(patient_id)] - time_to_evacuate)
                            chosen_ambulance = ambulance_id
                            chosen_hospital = hospital_idx



        # Print chosen ambulance and hospital for each patient
        # print(f"Patient {patient_id}: chosen ambulance = {chosen_ambulance}, chosen hospital = {chosen_hospital}")

        if chosen_ambulance is not None and chosen_hospital is not None:
            assignments[chosen_ambulance].append(patient_id)
            remaining_ambulance_capacity[chosen_ambulance] -= 2 * (patient_urgency[list(patient_nodes.keys()).index(patient_id)] + 1)
            remaining_hospital_capacities[chosen_hospital] -= 1

            ambulance_patients[chosen_ambulance].append(patient_id)
            hospital_patients[chosen_hospital].append(patient_id)

    return dict(assignments), dict(ambulance_patients), dict(hospital_patients)

# Attribuez les patients aux ambulances
assignments, ambulance_patients, hospital_patients = assign_patients_with_respect_to_evacuation_time(G, ambulance_nodes, patient_nodes, patient_urgence_etat, ambulance_capacities, hospital_capacities)
print(assignments)
print(ambulance_patients)
print(hospital_patients)

def get_node_coordinates(G):
    node_coordinates = {}
    for node, attrs in G.nodes(data=True):
        node_coordinates[node] = (attrs['x'], attrs['y'])
    return node_coordinates

from tqdm import tqdm

def find_optimal_routes(G, ambulance_nodes, patient_nodes, patient_urgence_etat, ambulance_capacity, hospital_nodes, hospital_capacities):

    optimal_routes = []

    node_coordinates = get_node_coordinates(G)

    remaining_patients = patient_nodes.copy()
    remaining_patient_urgence_etat = list(patient_urgence_etat)

    ambulances_patients = defaultdict(list)
    hospitals_patients = defaultdict(list)

    delta = 15
    iter = 100
    count = 0
    bar = tqdm(range(iter), desc="Processing", ncols=100)

    while remaining_patients and iter > count:
      for _ in bar:
          assignments, ambulance_patients, hospital_patients = assign_patients_with_respect_to_evacuation_time(G, ambulance_nodes, remaining_patients, remaining_patient_urgence_etat, ambulance_capacity, hospital_capacities)

          # print(remaining_patients)

          max_rotation_time = 0
          for ambulance_id, assigned_patients in assignments.items():
              itineraire = []
              total_time = 0
              current_position = ambulance_nodes[ambulance_id]
              remaining_capacity = ambulance_capacity[ambulance_id]

              for idx, patient_id in enumerate(assigned_patients, 1):
                  if remaining_capacity <= 0:
                      break

                  patient_node = patient_nodes[patient_id]
                  heuristic_func = partial(time_based_heuristic, G=G)
                  path_to_patient = nx.astar_path(G, current_position, patient_node, heuristic=heuristic_func)
                  path_to_patient_length = len(path_to_patient) - 1
                  time_to_patient = sum(G[path_to_patient[i]][path_to_patient[i + 1]][0]['length'] for i in range(path_to_patient_length))/100
                  # print(time_to_patient)
                  total_time += time_to_patient

                  if total_time > remaining_patient_urgence_etat[idx][0]:
                      continue

                  itineraire.extend(path_to_patient[:-1])
                  current_position = patient_node
                  remaining_capacity -= 1

                  fastest_paths = []
                  for hospital_node, capacity in zip(hospital_nodes, hospital_capacities):
                      try:
                        if capacity > 0:
                            path_to_hospital = nx.astar_path(G, patient_node, hospital_node, heuristic=heuristic_func)[1:]
                            fastest_paths.append((path_to_hospital, len(path_to_hospital)))
                      except:
                        continue
                  fastest_paths.sort(key=lambda x: x[1])

                  total_time += sum(G[fastest_paths[0][0][i]][fastest_paths[0][0][i + 1]][0]['length'] for i in range(len(fastest_paths[0][0]) - 1))/100

                  if total_time > remaining_patient_urgence_etat[idx][0]:
                      total_time -= time_to_patient
                      continue

                  itineraire.extend(fastest_paths[0][0])
                  if len(fastest_paths[0][0]) > 0:
                      current_position = fastest_paths[0][0][-1]
                      remaining_capacity += 1
                  else:
                      break

              max_rotation_time = max(max_rotation_time, total_time)
              itineraire_coords = [node_coordinates[node] for node in itineraire]
              optimal_routes.append(itineraire_coords)

              ambulances_patients[ambulance_id].extend(ambulance_patients[ambulance_id])

              for id_h, pts in hospital_patients.items():
                  if pts not in hospitals_patients[id_h]:
                      hospitals_patients[id_h].extend(pts)
                      hospitals_patients[id_h]=list(set(hospitals_patients[id_h]))




          evacuated_patients = set(patient_id for patients in assignments.values() for patient_id in patients)
          remaining_patients = {patient_id: coord for patient_id, coord in remaining_patients.items() if patient_id not in evacuated_patients}
          remaining_patient_urgence_etat = [(u, s) for patient_id, (u, s) in zip(patient_nodes.keys(), patient_urgence_etat) if patient_id not in evacuated_patients]




          rotation_time = max_rotation_time + delta
          for i, (urgency, state) in enumerate(remaining_patient_urgence_etat):
              remaining_patient_urgence_etat[i] = (urgency + rotation_time, state)

          count +=1
    bar.close()

    return [[i[::-1] for i in optimal_routes[id]]  for id, it in enumerate(optimal_routes)], ambulances_patients, hospitals_patients




# Trouvez les itinéraires optimaux pour chaque ambulance
optimal_routes, ambulance_patients, hospital_patients = find_optimal_routes(G, ambulance_nodes, patient_nodes, patient_urgence_etat, ambulance_capacity, hospital_nodes, hospital_capacities)

# Affichez les itinéraires optimaux
print(optimal_routes)

ambulance_patients, hospital_patients

len(optimal_routes)

import folium
import random
from folium.plugins import MarkerCluster
from folium.features import CustomIcon
# random.seed(55050)

def afficher_carte(optimal_routes, ambulance_nodes, patient_nodes, patient_urgence_etat, hospital_nodes, ambulance_patients, hospital_patients):

    # Extraire les positions des ambulances, des patients et des hôpitaux
    ambulances = [(G.nodes[node]['y'], G.nodes[node]['x']) for node in ambulance_nodes.values()]

    patients = [(G.nodes[node]['y'], G.nodes[node]['x']) for node in patient_nodes.values()]
    print(patients)
    hopitaux = [(G.nodes[node]['y'], G.nodes[node]['x']) for node in hospital_nodes]
    print(hopitaux)
    # Trouver le centre de la carte en utilisant les coordonnées des ambulances
    coord_centre = [(sum(lat for lat, lon in ambulances) / len(ambulances), sum(lon for lat, lon in ambulances) / len(ambulances))]
    print(coord_centre)
    # Initialiser la carte
    carte = folium.Map(location=coord_centre[0], zoom_start=13)

    # Couleurs pour les itinéraires
    couleurs = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue', 'darkpurple', 'pink', 'lightblue', 'lightgreen', 'gray', 'black', 'lightgray']
    couleurs = couleurs*10

    # Ajouter les marqueurs pour les patients, les ambulances et les hôpitaux
    icon_colors = {90: 'red', 240: 'orange', 1440: 'green'}

    patients_cluster = MarkerCluster(name="Patients", control=False)
    for (lat, lon), (i, j) in zip(patients, patient_urgence_etat):
        urgency = i
        folium.Marker(
            location=(lat, lon),
            icon=folium.Icon(color=icon_colors[urgency], icon="user", prefix="fa"),
            popup=f"Patient {'couché' if j==0 else 'assis'} - Urgence : délai {i} minutes",
        ).add_to(patients_cluster)

    patients_cluster.add_to(carte)

    ambulances_cluster = MarkerCluster(name="Ambulances", control=False)
    for idx, (lat, lon) in enumerate(ambulances):
        patients_evacues = ', '.join(map(str, ambulance_patients.get(idx, [])))
        folium.Marker(
            location=(lat, lon),
            icon=folium.Icon(color="blue", icon="ambulance", prefix="fa"),
            popup=f"Ambulance {idx + 1}<br>Patients évacués: {patients_evacues}",
        ).add_to(ambulances_cluster)
    ambulances_cluster.add_to(carte)

    hopitaux_cluster = MarkerCluster(name="Hôpitaux", control=False)
    for idx, (lat, lon) in enumerate(hopitaux):
        patients_admis = ', '.join(map(str, hospital_patients.get(idx, [])))
        folium.Marker(
            location=(lat, lon),
            icon=folium.Icon(color="red", icon="hospital", prefix="fa", icon_size=(30, 30)),
            popup=f"Hôpital {idx + 1}<br>Patients admis: {patients_admis}",
        ).add_to(hopitaux_cluster)
    hopitaux_cluster.add_to(carte)


    # Ajouter les itinéraires à la carte
    for idx, itineraire_coords in enumerate(optimal_routes):
        couleur = random.choice(couleurs)
        couleurs.remove(couleur)
        if len(itineraire_coords) > 0:
          folium.PolyLine(itineraire_coords, color=couleur, weight=7, opacity=1).add_to(carte)
          # Ajouter des marqueurs de début et de fin pour chaque itinéraire
          folium.Marker(
              location=itineraire_coords[0],
              icon=folium.Icon(color=couleur, icon="flag", prefix="fa"),
              popup=f"Départ Itinéraire {idx + 1}",
          ).add_to(carte)
          folium.Marker(
              location=itineraire_coords[-1],
              icon=folium.Icon(color=couleur, icon="flag-checkered", prefix="fa"),
              popup=f"Arrivée Itinéraire {idx + 1}",
          ).add_to(carte)

    folium.LayerControl().add_to(carte)

    # Afficher la carte
    return carte


# afficher_itineraires(optimal_routes, [list(i.keys())[0] for i in list(ambulances.values())], sum(list(patients.values()),[])[::2], list(hospitals.keys()))
afficher_carte(optimal_routes, ambulance_nodes, patient_nodes, patient_urgence_etat, hospital_nodes, ambulance_patients, hospital_patients)

result = ["Ambulance {} a transporté {} patients".format(i, len(ambulance_patients[i])) if len(ambulance_patients[i]) > 1 else "Ambulance {} a transporté {} patient".format(i, len(ambulance_patients[i])) for i in ambulance_patients]
print("\n".join(result))